\documentclass[12pt]{article}%
\usepackage{amsfonts}
\usepackage{fancyhdr}
\usepackage{comment}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2.2cm, right=2.2cm]%
{geometry}
\usepackage{amsmath}
\usepackage{changepage}
\usepackage{amssymb}
\usepackage{graphicx}%
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\setcounter{MaxMatrixCols}{30}
\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{axiom}{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\textbf{#1.} }{\ \rule{0.5em}{0.5em}}

\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\runningTime}[1]{$O(#1)$}
\newcommand{\correctAnswer}[1]{\textbf{\textcolor{red}{correct answer: #1  \\}}}

\begin{document}

\title{Assignment 4, 6.006, Introduction to Algorithms}
\author{Bryan Zhang}
\date{\today}
\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                Problem 1 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Problem 4-1. Hash Functions and Load}

\subsection{a}
\textbf{Answer: 3} \par
Hashing is to distribute every element equally randomly into a sub-slot.

\subsection{b} 
\textbf{Answer: 4}
Both are necessary because without collision resolution resize the hash-table can not preclude two elements with the same hash values from colliding into the same slot. While only chaining but without resizing the hash table, 	the load factor will bigger and bigger. Thus the running time is bigger and bigger, which drags the performance slow.

\subsection{c}
	\textbf{Answer: 6} \correctAnswer{7}
  \begin{algorithm}
   \caption{Risize the Hash-table}
    \begin{algorithmic}[4-1C]
      	\Function{Resize}{$oldTable, m'$}

	        \State allocate new memory of size m' \Comment{\runningTime{1}}
	        \For{slots in the newTabale}{ slots = NIL} \Comment{\runningTime{m'}}
	        \EndFor
	        \For{slots in the oldTable}{ make new slot in the newTable \For{item in the old slots}{  copy(item)}} \Comment{\runningTime{1}}
	        \EndFor  \Comment{\runningTime{n + m}}
	    \EndFunction \Comment{\runningTime{n + m + m'}}

    \end{algorithmic}
   \end{algorithm}
 Since m' > m, then the time complexity is \runningTime{n + m'}


\subsection{d}
\textbf{Answer:}
Theoretically the time complexity is \runningTime{n}. Since for n insertions, the cost is \runningTime{ k + k + k .... + k} while the the number of the terms is n/k. So the total cost is \runningTime{n^2}, thus \runningTime{n} amortized. \\
Practically, the memory system is binary. It is more convenient to allocate memory blocks doubly.


\section{Problem 4-2. Python Dictionary}
	\subsection{a}
	\textbf{Answer:} 1
	The "Member Testing" use cases states that the dictionary rarely changes not can't change.
	\subsection{b}
	\textbf{Answer:} 1 \correctAnswer{3}
	We need to first insert so many items that we need  a large minimum size. And Since we need quick performance for dictionary member testing, a sparse hash table is preferred. Thus the growth factor is 4.


\section{Problem 4-3. Matching DNA Sequences}



\end{document}